---
title: Java 集合
author: leo_shuo
createTime: 2024/08/10 17:03:02
permalink: /core/i13vi38s/
---
### 什么是集合

Java 中的集合是一组用来存储对象的容器，用于存储和操作对象，集合框架提供了许多不同类型的集合，如列表、集、映射等，使用集合可以让代码更加简洁、可读性更高，并且可以提高代码效率。Java 集合框架提供了许多接口和类来实现，常用的有 List、Set、Map

### 集合的分类

- List：
List 是一个有序的集合，可以存储重复的元素。它允许我们根据索引来访问其中的元素。在Java中，常用的List实现类有`ArrayList`和`LinkedList`。ArrayList基于数组实现，支持快速随机访问，而LinkedList则基于链表实现，支持高效的插入和删除操作。

- Set：
Set是一个无序的集合，不允许存储重复的元素。在Java中，常用的Set实现类有`HashSet`和`TreeSet`。HashSet基于哈希表实现，支持快速的查找操作，而TreeSet则基于红黑树实现，支持自然排序和范围查找操作。

- Map：
Map是一种键值对映射的数据结构，可以通过键来访问相应的值。在Java中，常用的Map实现类有**`HashMap`和`TreeMap`。HashMap基于哈希表实现，支持快速的查找操作，而TreeMap则基于红黑树实现，支持自然排序和范围查找操作。

### ArrayList 是什么

### HashMap 是什么

HashMap 是 Java 编程语言中常用的一种数据结构，它提供了一种快速的方式来存储和检索键值对，在 HashMap 中，键必须唯一，值可以重复。HashMap 使用哈希表来实现的，当插入键值对时，HashMap 会使用哈希函数来计算键的哈希码，并将键值对映射到相应的 Node 数组（桶）中，每个桶都包含一个链表或红黑树，用于处理哈希冲突，如果该桶为空，则直接将键值对插入其中，否则，就需要遍历链表或红黑树，找到正确的位置进行插入。

当两个键具有相同的哈希码，那么它们会被存储在同一个桶中，并以链表的形式存储，进行查找时，它会再次使用哈希函数来计算哈希码，并从相应的桶中搜索这个键，如果该桶为空，则说明该键不存在，否则，就需要遍历链表或红黑树，查找对应的键值对。因为 HashMap 是使用这种哈希表的形式实现的，所以插入和查找的效率很高，时间复杂度是常数级别 O(1)，当哈希冲突较多时，HashMap的性能可能会降低，因为需要遍历链表来查找键。哈希冲突是不可避免的，因此需要使用链表或红黑树来解决。当链表长度超过一定阈值时，链表会转换成红黑树，以提高查找效率。同时，当桶的数量过少时，也会触发扩容操作，以保证性能稳定

### HashMap 的扩容机制

当HashMap中的元素数量达到了负载因子（默认为0.75）乘以容量时，HashMap就会自动进行扩容操作。这个过程会创建一个新的数组，将所有原来的元素重新计算哈希值后放入新数组中。扩容的容量大小是原来的两倍。

在扩容期间，HashMap需要重新计算每个元素的哈希值，并且将它们放入新的数组中。由于哈希值的计算可能很耗时，所以在扩容过程中可能会导致一些性能问题。为了解决这个问题，Java 8 中的HashMap引入了树形化结构，当链表长度超过阈值（默认为8）时，会将链表转换成红黑树，从而提高查询效率。

### 并发使用Map的选择

- Hashtable
- Collections.synchronizedMap
- ConcurrentHashMap

### 并发使用 Hashtable 的缺陷

hashtable在几乎所有的方法上都加了synchronized同步锁，相当于给整个大的哈希表加了一把很大的锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞等待，性能很差

### 并发使用 synchronizedMap 方法的缺陷

本质上就是对HashMap的方法进行了一层包装 里面使用的也是对象锁来保证线程安全 本质上就是对HashMap进行了一个全表的一个加锁 所以性能也是很差的

### 并发使用 ConcurrentHashMap 的优点

初始化容量16、负载因子 0.75，采用的是分段锁，将 HashMap 进行切割，把 HashMap 中的哈希数组切分成小数组，每个小数组由若干个 HashEntry 组成，其中小数组继承自ReentrantLock 并发度更高，1.8以后ConcurrentHashMap也是数组+链表+红黑树，它只会锁住目前我获取到的entry所在的节点的值，上锁使用的是CAS加Synchronized，再加上JDK1.6以后对Synchronized进行了锁优化升级的过程，所以它的并发度更高