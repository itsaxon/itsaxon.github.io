import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o as l,b as i}from"./app-CWN1t9v-.js";const n={},t=i('<h1 id="java-基础" tabindex="-1"><a class="header-anchor" href="#java-基础"><span>Java 基础</span></a></h1><ul><li><p>Rapid Retrieve</p></li><li><p>Lnk</p><p>← <a href="https://www.notion.so/Resume-732000d5c5514023ae0524aeccd3293f?pvs=21" target="_blank" rel="noopener noreferrer">Resume</a> <a href="https://www.notion.so/Java-2d6682bd3285410fbf8c6c3184b22410?pvs=21" target="_blank" rel="noopener noreferrer">Java 集合</a> <a href="https://www.notion.so/Java-fa1a85b2803d4f21974da83ab7da8fb2?pvs=21" target="_blank" rel="noopener noreferrer">Java 并发</a> <a href="https://www.notion.so/Java-de1af6c3b86a477b8b0130844aa9fa82?pvs=21" target="_blank" rel="noopener noreferrer">Java 虚拟机</a></p></li></ul><hr><h3 id="jdk-jre-jvm-的关系" tabindex="-1"><a class="header-anchor" href="#jdk-jre-jvm-的关系"><span>JDK JRE JVM 的关系</span></a></h3><p>JDK指Java开发工具包，它包含JRE，JRE是运行时环境，它包含JVM虚拟机，JVM虚拟机是整个JAVA的核心，JVM内部包含很多应用程序的类解释器以及类加载器</p><h3 id="java的数据类型" tabindex="-1"><a class="header-anchor" href="#java的数据类型"><span>Java的数据类型</span></a></h3><p>基本数据类型</p><ul><li>整数 byte short int long</li><li>浮点数 float double</li><li>字符 char</li><li>布尔 boolean</li></ul><p>引用数据类型</p><ul><li>类</li><li>数组</li><li>接口</li></ul><h3 id="基本数据类型的长度" tabindex="-1"><a class="header-anchor" href="#基本数据类型的长度"><span>基本数据类型的长度</span></a></h3><ul><li>byte 1</li><li>short 2</li><li>int 4</li><li>long 8</li><li>float 4</li><li>double 8</li><li>char 2</li><li>boolean 1</li></ul><h3 id="switch支持的类型" tabindex="-1"><a class="header-anchor" href="#switch支持的类型"><span>switch支持的类型</span></a></h3><ul><li>JDK1.5之前支持 byte、short、int、char</li><li>JDK1.5之后支持 Integer、Enum</li><li>JDK1.7之后支持 String</li></ul><h3 id="static关键字的作用" tabindex="-1"><a class="header-anchor" href="#static关键字的作用"><span>static关键字的作用</span></a></h3><ul><li>修饰成员变量 成员方法的时候 无论创建多少对象 都只有一份 存在方法区 用类名调用</li><li>修饰静态代码块 无论创建多少对象 只会初始化一次 一般用来加载静态资源</li><li>作为静态导包 JDK1.5的功能</li></ul><h3 id="final关键字的作用" tabindex="-1"><a class="header-anchor" href="#final关键字的作用"><span>final关键字的作用</span></a></h3><ul><li>修饰类 类不可被继承</li><li>修饰方法 方法不能被重写</li><li>修饰变量 变量的引用不可改变</li></ul><h3 id="final-finally-finalize的区别" tabindex="-1"><a class="header-anchor" href="#final-finally-finalize的区别"><span>final finally finalize的区别</span></a></h3><ul><li>finally 用在try-catch代码中 表示无论是否发生异常 finally里的代码都会执行 通常用来存放关闭资源的代码</li><li>finalize Object类的一个方法 由垃圾回收器调用 调用System.gc()方法 垃圾回收器会调用finalize方法 做一个将对象从内存中清除出去之前的清理工作</li></ul><h3 id="equals-的区别" tabindex="-1"><a class="header-anchor" href="#equals-的区别"><span>== equals 的区别</span></a></h3><p>对于基本数据类型以及String来说<mark>比较的是值 对于引用数据类型来说</mark>比较的是地址 equals默认比较的是地址 重写可以比较内容</p><h3 id="值传递-引用传递-的区别" tabindex="-1"><a class="header-anchor" href="#值传递-引用传递-的区别"><span>值传递 引用传递 的区别</span></a></h3><p>值传递 传的是一个值 相当于传了一个副本 形参和实参互不影响 引用传递 传的是一个引用地址 形参实参指向同一对象 形参的改变就是实参的改变</p><h3 id="浅拷贝-深拷贝的区别" tabindex="-1"><a class="header-anchor" href="#浅拷贝-深拷贝的区别"><span>浅拷贝 深拷贝的区别</span></a></h3><p>浅拷贝 对于基本数据类型来说是直接拷贝的值 对于引用数据类型来说是拷贝的引用 但是不会拷贝对象 原始对象和副本都是指向同一个对象 深拷贝 对于基本数据类型来说是直接拷贝的值 对于引用数据类型来说是拷贝的引用和对象 指向的是一个新对象</p><h3 id="什么是面向对象" tabindex="-1"><a class="header-anchor" href="#什么是面向对象"><span>什么是面向对象</span></a></h3><p>面向对象是一种程序设计思想 是针对面向过程而言的 在程序设计过程中 参照现实中事物 将事物的属性 行为抽象出来 描述成计算机程序 这样一种方式就是面向对象</p><h3 id="面向对象-面向过程的区别" tabindex="-1"><a class="header-anchor" href="#面向对象-面向过程的区别"><span>面向对象 面向过程的区别</span></a></h3><p>面向过程主要是以实现功能的函数开发为主，面向对象需要抽象出类 属性 方法 实例化类 执行方法来完成功能，都具有封装性，面向过程封装的是功能，面向对象封装的是数据和功能，面向对象具有继承性和多态性，面向过程没有</p><h3 id="面向对象的特征" tabindex="-1"><a class="header-anchor" href="#面向对象的特征"><span>面向对象的特征</span></a></h3><ul><li>封装 对程序代码的一种保护 可以隐藏类的实现细节 对外提供公共的访问方式 提高代码安全性</li><li>继承 让类与类之间产生关系 子类继承父类 可以使用父类的属性方法 提高代码的复用性</li><li>多态 一个类具有多种不同的表现形态 前提要有父类的引用指向子类的实例 提高代码的拓展性</li></ul><h3 id="创建对象的方式" tabindex="-1"><a class="header-anchor" href="#创建对象的方式"><span>创建对象的方式</span></a></h3><ul><li>new</li><li>Object类 clone</li><li>反序列化</li><li>Class类 newInstance</li></ul><h3 id="string类常用的方法" tabindex="-1"><a class="header-anchor" href="#string类常用的方法"><span>String类常用的方法</span></a></h3><ul><li>equals</li><li>indexOf</li><li>substring</li><li>startsWith</li><li>split</li></ul><h3 id="string-stringbuffer-stringbuilder-的区别" tabindex="-1"><a class="header-anchor" href="#string-stringbuffer-stringbuilder-的区别"><span>String StringBuffer StringBuilder 的区别</span></a></h3><ul><li>String是不可变的 使用被final修饰的字符数组存储数据 StringBuffer StringBuilder继承AbstractStringBuilder使用的是字符数组 是可变的</li><li>String被final修饰 线程安全 StringBuffer在方法上加了同步锁 线程安全 StringBuilder不安全</li><li>修改String 返回的是新的String对象 性能低 StringBuffer StringBuilder 返回的是本身 性能高</li></ul><h3 id="什么是-装箱-拆箱" tabindex="-1"><a class="header-anchor" href="#什么是-装箱-拆箱"><span>什么是 装箱 拆箱</span></a></h3><p>装箱 基本数据类型转换为对应的包装类型 拆箱 基本类型对应的包装类型转换为基本类型 JDK1.5之后自动装箱拆箱</p><h3 id="运行时异常-与-编译时异常-的区别" tabindex="-1"><a class="header-anchor" href="#运行时异常-与-编译时异常-的区别"><span>运行时异常 与 编译时异常 的区别</span></a></h3><p>运行时异常是编译器不强制处理的异常 出现在程序运行的时候 都是RuntimeException异常 编译时异常是编译器强制要求处理的异常 不处理代码无法编译 都是RuntimeException以外的异常</p><h3 id="常见运行时异常" tabindex="-1"><a class="header-anchor" href="#常见运行时异常"><span>常见运行时异常</span></a></h3><ul><li>NullPointException</li><li>ArrayIndexOutOfBoundsException</li><li>IndexOutOfBoundsException</li><li>NumberFormatException</li><li>ArrayStoreException</li></ul><h3 id="常见编译时异常" tabindex="-1"><a class="header-anchor" href="#常见编译时异常"><span>常见编译时异常</span></a></h3><ul><li>SQLException</li><li>ClassNotFoundException</li><li>FileNotFoundException</li><li>ParseException</li><li>IOException</li></ul><h3 id="什么是反射" tabindex="-1"><a class="header-anchor" href="#什么是反射"><span>什么是反射</span></a></h3><p>把Java类中的各个成分映射为一个个的Java对象，这个过程称为反射机制</p><h3 id="反射的原理" tabindex="-1"><a class="header-anchor" href="#反射的原理"><span>反射的原理</span></a></h3><p>任何一个编译过的class文件在被类加载器加载后 都会有一个Class类实例 通过获取这个类的class字节码对象 就可以获取这个类的实例 属性 方法等 也可以通过getset方法获取变量的值</p><h3 id="抽象类与接口的区别" tabindex="-1"><a class="header-anchor" href="#抽象类与接口的区别"><span>抽象类与接口的区别</span></a></h3><ul><li>抽象类是abstract 接口是interface</li><li>抽象类里有成员变量 成员方法 抽象方法 接口里有常量 抽象方法</li><li>抽象类里成员变量的定义和普通类一样 接口会加上public static final 变成常量</li><li>抽象类遵循的是is a的设计原则 接口是has a</li><li>抽象类一般充当公共类的角色 不适用于修改维护 接口用于实现常用的功能 适用于修改维护</li><li>接口比抽象类更为抽象</li></ul><h3 id="元注解分类" tabindex="-1"><a class="header-anchor" href="#元注解分类"><span>元注解分类</span></a></h3><ul><li>Retention</li><li>Target</li><li>Document</li><li>Inherited</li></ul><h3 id="长连接与短连接的区别" tabindex="-1"><a class="header-anchor" href="#长连接与短连接的区别"><span>长连接与短连接的区别</span></a></h3><p>长连接是在一个连接上可以连续发送多个数据包 在连接期间 如果没有数据包发送需要双方发链路检测包 短连接是通讯双方有数据交互时 就建立一个连接 数据发送完成 断开连接</p><h3 id="int-为什么是四个字节" tabindex="-1"><a class="header-anchor" href="#int-为什么是四个字节"><span>int 为什么是四个字节</span></a></h3><p>一个字节是计算机存储数据的基本单位。它等于8个比特（bit），每个比特只能为0或1。因此，一个字节可以用二进制表示为8个位（位=比特）。例如，以下是一个字节的二进制表示：01010110。</p><p>首先 Java 中的 int 类型占用4个字节是由 Java 语言规范所决定的。这样做是为了确保 Java 程序在不同平台上的兼容性，为了保证Java程序在不同操作系统上都能正确地运行，并提高内存利用率。在32位操作系统中，int 占4个字节，64位则是8个字节。因为32位系统和64位系统使用的CPU架构不同。32位系统使用32位寻址，即内存地址被限制在32位范围内。因此，32位系统最多只能寻址2^32个字节（4GB）。而一个32位的 int 数据类型正好占用4个字节，可以轻松地在32位系统中存储和处理。对于64位系统，使用64位架构，所以CPU可以处理更大的数据。因此，int 数据类型被定义为8个字节，可以存储更大范围的整数。</p>',59),r=[t];function s(h,c){return l(),a("div",null,r)}const p=e(n,[["render",s],["__file","Java基础.html.vue"]]),u=JSON.parse('{"path":"/demo/Java%E5%9F%BA%E7%A1%80.html","title":"Java 基础","lang":"en-US","frontmatter":{"description":"Java 基础 Rapid Retrieve Lnk ← Resume Java 集合 Java 并发 Java 虚拟机 JDK JRE JVM 的关系 JDK指Java开发工具包，它包含JRE，JRE是运行时环境，它包含JVM虚拟机，JVM虚拟机是整个JAVA的核心，JVM内部包含很多应用程序的类解释器以及类加载器 Java的数据类型 基本数据类型 ...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/demo/Java%E5%9F%BA%E7%A1%80.html"}],["meta",{"property":"og:site_name","content":"Docs Demo"}],["meta",{"property":"og:title","content":"Java 基础"}],["meta",{"property":"og:description","content":"Java 基础 Rapid Retrieve Lnk ← Resume Java 集合 Java 并发 Java 虚拟机 JDK JRE JVM 的关系 JDK指Java开发工具包，它包含JRE，JRE是运行时环境，它包含JVM虚拟机，JVM虚拟机是整个JAVA的核心，JVM内部包含很多应用程序的类解释器以及类加载器 Java的数据类型 基本数据类型 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-08-06T09:59:23.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2024-08-06T09:59:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 基础\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-06T09:59:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":3,"title":"JDK JRE JVM 的关系","slug":"jdk-jre-jvm-的关系","link":"#jdk-jre-jvm-的关系","children":[]},{"level":3,"title":"Java的数据类型","slug":"java的数据类型","link":"#java的数据类型","children":[]},{"level":3,"title":"基本数据类型的长度","slug":"基本数据类型的长度","link":"#基本数据类型的长度","children":[]},{"level":3,"title":"switch支持的类型","slug":"switch支持的类型","link":"#switch支持的类型","children":[]},{"level":3,"title":"static关键字的作用","slug":"static关键字的作用","link":"#static关键字的作用","children":[]},{"level":3,"title":"final关键字的作用","slug":"final关键字的作用","link":"#final关键字的作用","children":[]},{"level":3,"title":"final finally finalize的区别","slug":"final-finally-finalize的区别","link":"#final-finally-finalize的区别","children":[]},{"level":3,"title":"== equals 的区别","slug":"equals-的区别","link":"#equals-的区别","children":[]},{"level":3,"title":"值传递 引用传递 的区别","slug":"值传递-引用传递-的区别","link":"#值传递-引用传递-的区别","children":[]},{"level":3,"title":"浅拷贝 深拷贝的区别","slug":"浅拷贝-深拷贝的区别","link":"#浅拷贝-深拷贝的区别","children":[]},{"level":3,"title":"什么是面向对象","slug":"什么是面向对象","link":"#什么是面向对象","children":[]},{"level":3,"title":"面向对象 面向过程的区别","slug":"面向对象-面向过程的区别","link":"#面向对象-面向过程的区别","children":[]},{"level":3,"title":"面向对象的特征","slug":"面向对象的特征","link":"#面向对象的特征","children":[]},{"level":3,"title":"创建对象的方式","slug":"创建对象的方式","link":"#创建对象的方式","children":[]},{"level":3,"title":"String类常用的方法","slug":"string类常用的方法","link":"#string类常用的方法","children":[]},{"level":3,"title":"String StringBuffer StringBuilder 的区别","slug":"string-stringbuffer-stringbuilder-的区别","link":"#string-stringbuffer-stringbuilder-的区别","children":[]},{"level":3,"title":"什么是 装箱 拆箱","slug":"什么是-装箱-拆箱","link":"#什么是-装箱-拆箱","children":[]},{"level":3,"title":"运行时异常 与 编译时异常 的区别","slug":"运行时异常-与-编译时异常-的区别","link":"#运行时异常-与-编译时异常-的区别","children":[]},{"level":3,"title":"常见运行时异常","slug":"常见运行时异常","link":"#常见运行时异常","children":[]},{"level":3,"title":"常见编译时异常","slug":"常见编译时异常","link":"#常见编译时异常","children":[]},{"level":3,"title":"什么是反射","slug":"什么是反射","link":"#什么是反射","children":[]},{"level":3,"title":"反射的原理","slug":"反射的原理","link":"#反射的原理","children":[]},{"level":3,"title":"抽象类与接口的区别","slug":"抽象类与接口的区别","link":"#抽象类与接口的区别","children":[]},{"level":3,"title":"元注解分类","slug":"元注解分类","link":"#元注解分类","children":[]},{"level":3,"title":"长连接与短连接的区别","slug":"长连接与短连接的区别","link":"#长连接与短连接的区别","children":[]},{"level":3,"title":"int 为什么是四个字节","slug":"int-为什么是四个字节","link":"#int-为什么是四个字节","children":[]}],"git":{"createdTime":1722938363000,"updatedTime":1722938363000,"contributors":[{"name":"itsaxon","email":"18856655661@163.com","commits":1}]},"readingTime":{"minutes":6.43,"words":1929},"filePathRelative":"demo/Java基础.md","localizedDate":"August 6, 2024","autoDesc":true}');export{p as comp,u as data};
